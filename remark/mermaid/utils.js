/* eslint-disable no-console */
/* eslint-disable no-sync */

const crypto = require('crypto');
const path = require('path');
const YAML = require('yaml');
const merge = require('lodash.merge');

const fs = require('fs-extra');
const mermaidIsomorphic = require('mermaid-isomorphic');
const { optimize } = require('svgo');

const { MERMAID_DIR, PLUGIN_NAME } = require('./constants');

const CSS_PATH = path.join(__dirname, 'style.css');

const createHash = (...data) =>
  data
    .map((datum) =>
      crypto.createHmac('sha1', PLUGIN_NAME).update(datum).digest('hex'),
    )
    .reduce(
      (hmac, hex) => hmac.update(hex),
      crypto.createHmac('sha1', PLUGIN_NAME),
    )
    .digest('hex');

const mermaidConfig = {
  er: {
    diagramPadding: 1,
    useMaxWidth: false,
  },
  flowchart: {
    diagramPadding: 1,
    useMaxWidth: false,
  },
  gantt: {
    barGap: 7,
    barHeight: 28,
    gridLineStartPadding: 0,
    leftPadding: 70,
    rightPadding: 70,
    titleTopMargin: 0,
    topPadding: 70,
    useMaxWidth: false,
  },
  sequence: {
    bottomMarginAdj: 14,
    boxMargin: 14,
    diagramMarginX: 1,
    diagramMarginY: 1,
    mirrorActors: true,
    useMaxWidth: false,
  },
  themeCSS: fs.readFileSync(CSS_PATH, 'utf8'),
};

const mermaidConfigString = JSON.stringify(mermaidConfig);

const generateFilePaths = (rootDir, data) => {
  const hash = createHash(data, mermaidConfigString);

  return {
    mmdPath: path.join(rootDir, MERMAID_DIR, `.${hash}.mmd`),
    rawSvgPath: path.join(rootDir, MERMAID_DIR, `.${hash}.raw.svg`),
    // `imageToJsx` will resolve this URL relative to `rootDir`.
    svgNodeUrl: path.join('/', MERMAID_DIR, `.${hash}.mmd.svg`),
    svgPath: path.join(rootDir, MERMAID_DIR, `.${hash}.mmd.svg`),
  };
};

function createMermaidRenderer(options) {
  const renderer = mermaidIsomorphic.createMermaidRenderer(options);

  async function renderNodes(nodes) {
    const mapped = nodes.map((node) => {
      const paths = generateFilePaths(options.rootDir, node.value);
      const frontmatter = node.value.startsWith('---')
        ? YAML.parse(node.value.match(/---([\s\S]*?)---/)[1]) ?? {}
        : {};

      return {
        ...paths,
        value: node.value,
        frontmatter,
        exists: fs.existsSync(paths.svgPath),
      };
    });

    if (mapped.length > 1 && mapped.some((n) => n.frontmatter.overrides)) {
      // If any node has an override, render all nodes separately because we pass config globally
      return await Promise.all(
        nodes.map(async (node) => (await renderNodes([node]))[0]),
      );
    }

    if (mapped.every(({ exists }) => exists)) {
      return mapped.map(({ svgNodeUrl }) => ({
        status: 'fulfilled',
        value: { svgNodeUrl },
      }));
    }

    const toRender = mapped
      .map((n, i) => (console.log(n), { ...n, originalIndex: i }))
      .filter(({ exists }) => !exists);

    const results = await renderer(
      toRender.map(({ value }) => value),
      {
        ...options,
        mermaidConfig: merge(
          {},
          mermaidConfig,
          ...toRender.map(({ frontmatter }) => frontmatter.overrides),
        ),
      },
    );

    const errorResults = new Map();

    results.forEach((result, i) => {
      if (result.status === 'rejected') {
        errorResults.set(toRender[i].originalIndex, result);
      } else {
        const { svg } = result.value;

        const { data } = optimize(svg, {
          plugins: [
            {
              // Remove some stubborn inline styles generated by mermaid.
              name: 'removeAttrs',
              params: {
                attrs: 'style',
              },
            },
          ],
        });

        fs.writeFileSync(toRender[i].svgPath, data);
      }
    });

    return mapped.map(
      ({ svgNodeUrl }, i) =>
        errorResults.get(i) ?? { status: 'fulfilled', value: { svgNodeUrl } },
    );
  }

  return renderNodes;
}

module.exports = {
  createMermaidRenderer,
};
